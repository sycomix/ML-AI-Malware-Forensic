from meta_file2 import load_data
import numpy as np
from numpy import array
from sklearn import tree
import graphviz
data=load_data()
import sys
import collections
import math

reload(sys)
sys.setdefaultencoding('utf8')

clf = tree.DecisionTreeClassifier()

clf.fit(data.data, list(data.target))
#print (data.feature_names)
#print data.data_test
prediction=clf.predict(data.data_test)
#print prediction
from sklearn.externals.six import StringIO
import pydotplus
#dot_data = StringIO()
#dot_data=tree.export_graphviz(clf, out_file=None,
#                         feature_names=data.feature_names,
#                         #class_names=data.target_names,
#                         filled=True, rounded=True,
#                         impurity=False)
#print dot_data
#edges = collections.defaultdict(list)
target_dic = {0:"Normal", 1:"MSGHOOK", 2:"MALFIND", 4:"EVENTHOOK",8:"APIHOOK",16:"DKOM"}

#return number with highest power of 2  in the range n
def Po2(n):
    p=int(math.log(n,2))
    return pow(2,p)

#a=[]
# fill target_dic by appending all previous values whose combination of keys are equal to i
def valsum():
    for i in range(1,32):
        if (i==target_dic.keys()):
            continue
        else:
            p2=Po2(i)
            for j in range(1,p2):
                if(j+p2==i):
                    #print (j,p2)
                    target_dic[i]=target_dic[j]+"-"+target_dic[p2]
    #print target_dic

#valsum()
# map the result of decision tree prediction with the values in target_dic. Print values
def translate():
    b=[]
    c=[]
    for j, i in enumerate(prediction):
           if(int(i) in target_dic):
              # b.append(target_dic[i])
              b.append("Process with ID "+str(data.test_PID[j])+" and Process Name "+data.test_Pname[j]+" With offset "+data.test_offset[j]+" has behavior of "+target_dic[i])
            #  c.append(data.test_PID[j])


    for i in b:
        print (i+"\n")
